### Number类型

ECMAScript中最有意思的数据类型或许就是Number了。Number类型使用EEE 754格式表示整数和浮点值(在某些语言中也叫双精度值)。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可:
```js
let intNum = 55; //整数
```
整数也可以用八进制(以8为基数)或十六进制(以16为基数)字面量表示。对于八进制字面量，第一一个数字必须是零(0) ,然后是相应的八进制数字(数值0~7)。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成+进制数，如下所示:

```js
let octalNum1 = 070; // 八进制的56
let octalNum2 = 079;//无效的八进制值，当成79处理
let octalNum3 = 08;//无效的八进制值，当成8处理
```

八进制字面量在严格模式下是无效的，会导致JavaScript弓|擎抛出语法错误。

要创建十六进制字面量，必须让真正的数值前缀Ox (区分大小写)，然后是十六进制数字(0~9以及A~F).十六进制数字中的字母大小写均可。下面是几个例子:
```js
let hexNum1 = 0xA; //十六进制10
let hexNum2 = 0x1f; // 十六进制31
```

使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

注意由于JavaScript保存数值的方式，实际中可能存在正零(+0) 和负零(-0)、正零和负零在所有情况下都被认为是等同的，这里特地说明一下。

**1.浮点值**


要定义浮点值，数值中必须包含小数点,而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子:

```js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐
```
因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0 (如1.0)
```js
let floatNum1 = 1;//小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0; //小数点后面是零，当成整数10处理
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值(整数或浮点数)后跟一个大写或小写的字母e,再加上一个要乘的10的多少次幂。比如:
```js
let floatNum = 3.125e7; //等于31250000
```

在这个例子中，floatNum等 于31250000 ,只不过科学记数法显得更简洁。这种表示法实际上相当于说:”以3.125作为系数， 乘以10的7次幂。”

科学记数法也可以用于表示非常小的数值，例如0.0000000000000003.这个数值用科学记数法可以表示为3e-17。默认情况下,ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法(例如，0.0000003会被转换为3e-7)。术计算中远不如整数精确。

例如，0.1加0.2得到的不是0.3而是0.3000000000000004。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下面的例子:
```js
if(a + b==0.3) {//别这么干!
    console.log("You got 0.3.");
}
```
这里检测两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15,那没问题。但如果是0.1和0.2,如前所述，测试将失败。因此永远不要测试某个特定的浮点值。

注意之所以存在这种舍入错误，是因为使用了IEEE754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。

**2.值得范围**

由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN VALUE中，这个值在多数浏览器中是5e-324;可以表示的最大数值保存在Number.MAX_ VALUE中，这个值在多数浏览器中是1.797693134862315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity (无穷)值。任何无法表示的负数以-Infinity (负无穷大)表示，任何无法表示的正数以Infinity (正无穷大)表示。

如果计算返回正Infinity或负Infinity,则该值将不能再进一步用于任何计算。这是因为Infinity没有可用于计算的数值表示形式。要确定一个值是不是有限大(即介于JavaScript能表示的最小值和最大值之间)可以使用isFinite()函数，如下所示:

```js
let result = Number.MAX VALUE + Number.MAX VALUE;
console.log(isFinite(result)); // false
```

虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果 是否超出范围。

注意使用Number.NEGATIVE INFINITY和Number.POSITIVE INFINITY也可以获取正、负Infinity。 没错，这两个属性包含的值分别就是-Infinity和Infinity。

**3.NaN**

有一个特殊的数值叫NaN，意思是"不是数值"(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误) 。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相 除会返回NaN:

```js
console.log(0/0);// NaN
console.log(-0/+0); // NaN 
```
如果分子是非0值，分母是有符号0或无符号0,则会返Infinity或-Infinity:

```js
console.log(5/0); // Infinity
console.log(5/-0); // -Infinity
```

NaN有几个独特的属性。首先，任何涉及NaN的操作始终返回NaN (如NaN/10).在连续多步计算时这可能是个问题。其次,NaN不等于包括NaN在内的任何值。例如，下面的比较操作会返回false: 

```js
console.log(NaN == NaN); //false
```

为此，ECMAScript提供 了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否"不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下: 
```js
console.log(isNaN(NaN));// true
console.log(isNaN(10)); // false, 10是数值
console.log(isNaN("10")); // false,可以转换为数值10
console.log(isNaN("blue")); // true,不可以转换为数值
console.log(isNaN(true));// false,可以转换为数值1
```

上述的例子测试了5个不同的值。首先测试的是NaN本身，显然会返回true。接着测试了数值10和字符串"10"， 都返回false， 因为它们的数值都是10。字符串"blue"不能转换为数值，因此函数返回true。布尔值true可以转换为数值1，因此返回false。

注意虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString(方法,并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式


**4.数值转换**

有3个函数可以将非数值转换为数值:

Number()、parselnt()和parseFloat()。

Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number()函数基于如下规则执行转换。

* 布尔值，true转换为1， false转换为0
* 数值，直接返回
* null,返回0
* undefined,返回NaN
* 字符串，应用一下规则
  * 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此Number("1")返回1,Number("123")返回123,Number("011")返回11 (忽略前面的零)
  * 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值(同样，忽略前面的零)
  * 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值。
  * 如果是空字符串(不包含字符)则返回0。
  * 如果字符串包含除上述情况之外的其他字符，则返回NaN。
* 对象，调用valueOf()方法，并按照上述规则转换返回的值。如果转换结果是NaN,则调用toString(方法，再按照转换字符串的规则转换。

从不同数据类型到数值的转换有时候会比较复杂，看一看Number)的转换规则就知道了。下面是几个具体的例子:

```js
let num1 = Number("Hello world! "); //NaN
let num2 = Number("");//0
let num3 = Number("000011");// 11
let num4 = Number(true);// 1
```

可以看到，字符串"Hello world"转换之后是NaN,因为它找不到对应的数值。空字符串转换后是0。字符串000011转换后是11，因为前面的零被忽略了。最后，true转换为1。

考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数。 

parselnt()函数更专注于字符串是否包含数值模式。

字符串最前面的空格会被忽略，从第一一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parselnt()立即返回NaN。 

这意味着空字符串也会返回NaN (这一 -点跟Number(不一样，它返回0)。

如果第一一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。

比如"1234blue"会被转换为1234 ,因为"blue"会被完全忽略。类似地，"22.5"会被转换为22，因为小数点不是有效的整数字符。

假设字符串中的第一个字符是数值字符，parselnt()函数也能识别不同的整数格式(十进制、八进制、十六进制)。换句话说，如果字符串以"0x"开头，就会被解释为十六进制整数。如果字符串以"0"开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。

下面几个转换示例有助于 理解上述规则:

```js
let num1 = parseInt("1234blue"); // 1234
let num2 = parselnt("");// NaN
let num3 = parselnt("OxA");//10，解释为十六进制整数
let num4 = parselnt(22.5);// 22
let num5 = parselnt("70");// 70，解释为十进制值
let num6 = parselnt("0xf");// 15，解释为十六进制整数
```

不同的数值格式很容易混淆，因此parselnt()也接收第二个参数，用于指定底数(进制数)。如果知道要解析的值是十六进制，那么可以传入16作为第二个参数，以便正确解析:

```js
let num = parselnt("0xAF", 16); // 175
```

事实上，如果提供了十六进制参数，那么字符串前面的"Ox"可以省掉:

```js
let num1 = parselnt("AF", 16); // 175
let num2 = parselnt("AF");// NaN
```

在这个例子中，第一个转换是正确的，而第二个转换失败了。

区别在于第一次传入了进制数作为参数，告诉parseInt()要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字符，随即自动停止并返回NaN。

通过第二个参数，可以极大扩展转换后获得的结果类型。比如:

```js
let num1 = parselnt("10",2); //2，按二进制解析
let num2 = parselnt("10", 8); //8， 按八进制解析
let num3 = parselnt("10", 10); // 10，按十进制解析
let num4 = parselnt("10", 16); // 16,按十六进制解析
```

因为不传底数参数相当于让parselnt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。

注意多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。

parseFloat()函数的工作方式跟parselnt()函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点现的小数点是有效的，但第二次出现的小数点略。因此，"22.34.5"将转换成22.34。

parseFloat()函数的另一一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式(开头的零始终被忽略)。十六进制数值始终会返回0。因为parseFloat() 只解析十进制值，因此不能指定底数。最后，如果字符串表示整数(没有小数点或者小数点后面只有一一个零)则parseFloat()返回整数。下面是几个示例:

```js
let num1 = parseFloat(" 1234blue"); //1234,按整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5");// 22.5
let num4 = parseFloat( "22.34.5");// 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); //31250000
```