## 数据类型

ECMAScript有6种简单数据类型(也称为原始类型) : 

Undefined、Null、Boolean、Number、 String和Symbol。 Symbol (符号)是ECMAScript 6新增的。

还有一种复杂数据类型叫object (对象)。Object是一种无序名值对的集合。

因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。

只有7种数据类型似乎不足以表示全部数据。

但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。

### typeof操作符
因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。

typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一:
* "undefined"表示值未定义;
* "boolean"表示值为布尔值;
* "string"表示值为字符串;
* "number"表示值为数值;
* "object"表示值为对象(而不是函数)或null;
* "function"表示值为函数;
* "symbol"表示值为符号。

下面是使用typeof操作符的例子:

```js
let message = ' some string' ;
console.log(typeof message);// "string"
console.log(typeof(message)); // "string
console.log(typeof 95);// "number"
```

在这个例子中，我们把一个变量( message)和一个数值字面量传给了typeof操作符。

注意，因为typeof是一个操作符而不是函数，所以不需要参数(但可以使用参数)

注意, typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。


**注意**

严格来讲，函数在ECMASrip中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。

### Undefined类型
Undefined类型只有一个值,就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值:

```js
let message;
console.log(message == undefined); //ture
```

在这个例子中，变量message在声明的时候并未初始化。而在比较它和undefined的字面值时，两者是相等的。这个例子等同于如下示例:
```js
let message=undefined;
console.log(message == undefined); // true
```
这里，变量message显 式地以undefined来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得undefined值。

**注意**

一般来说，永远不用显式地给某个变量设置undefined值。字面值undefined主要用于比较，而且在ECMA-262第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针(null) 和未初始化变量的区别。

注意，包含undefined值的变 量跟未定义变量是有区别的。请看下面的例子:

```js
let message;// 这个变量被声明了，只是值为undefined
//确保没有声明过这个变量
// let age
console.log(message); // "undefined"
console.log(age); // 报错
```

在上面的例子中，第一-个console.log会指出变量message的值，即"undefined"。 而第二个console.log要输出一个未声明的变量age的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用typeof。(对未声明的变 量调用delete也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。)在对未初始化的变量调用typeof时，返回的结果是"undefined"，但对未声明的变量调用它时，返回的结果还是"undefined",这就有点让人看不懂了。比如下面的例子:

```js
let message; //这个变量被声明了，只是值为undefined
//确保没有声明过这个变量
//let age
console.log(typeof message);//"undefined" 
console.log(age);//"undefined"
```
无论是声明还是未声明，typeof返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。

**注意**

即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的同时进行初始化。

这样，当typeof返回"undefined"时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

undefined是一个假值。 因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以-定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。

```js
let message; //这个变量被声明了，只是值为undefined
// age没有声明
if (message) {
    //这个块不会执行
}
if(!message) {
    //这个块会执行
}
if (age) {
    //这里会报错
}
```

### Null类型
Null类型同样只有一个值，即特殊值null。 逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因:

```js
let car = null;
console.log(typeof car);
```
在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值。

这样只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如:

```js
if(car != null) {
    //car是一个对象引用
}
```
undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等,如下面的例子所示:
```js
console.log(null == undefined); //true
```

用等于操作符(==) 比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数

即使null和undefined有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为undefined。但null不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。

null是一个假值。 因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是null这个字面值，而不仅仅是假值。

```js
let message = null;
let age;
if (message) {
    //这个块不会执行
}
if (! message) {
    //这个块会执行
}
if(age) {
    //这个块不会执行
}
if!age) {
    //这个块会执行
}
```

### Boolean 类型

Boolean (布尔值)类型是ECMAScript中使用最频繁的类型之一，有两个字面值: true和false。

这两个布尔值不同于数值，因此true不等于1，false不等于0。下面是给变量赋布尔值的例子: 
```js
let found = true;
let lost =false;
```

注意布尔值字面量true和false是区分大小写的，因此True和False (及其他大小混写形式)是有效的标识符，但不是布尔值。虽然布尔值只有两个但所有其他ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的Boolean()转型函数:

```js
let message = "Hello world!";
let messageAsBoolean = Boolean(message);
```
在这个例子中，字符串message会被转换为布尔值并保存在变量messageAsBoolean中。Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为true或false的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。
* 数据类型 - 转化为true的值 - 转化为false的值
* Boolean - true - false
* String - 非空字符串 - ""(空字符串)
* Number - 非零数组(包括无穷值) - 0、NaN
* Object - 任意对象 - null
* Undefined - N/A(不存在) - undefined

理解以上转换非常重要，因为像if等流控制语句会自动执行其他类型值到布尔值的转换，例如:

```js
let message = "Hello world!";
if (message) {
    console.log("Value is true");
}
```
在这个例子中，console.log 会输出字符串"Value is true"，因为字符串message会被自动转换为等价的布尔值true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。

### Number类型

ECMAScript中最有意思的数据类型或许就是Number了。Number类型使用EEE 754格式表示整数和浮点值(在某些语言中也叫双精度值)。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可:
```js
let intNum = 55; //整数
```
整数也可以用八进制(以8为基数)或十六进制(以16为基数)字面量表示。对于八进制字面量，第一一个数字必须是零(0) ,然后是相应的八进制数字(数值0~7)。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成+进制数，如下所示:

```js
let octalNum1 = 070; // 八进制的56
let octalNum2 = 079;//无效的八进制值，当成79处理
let octalNum3 = 08;//无效的八进制值，当成8处理
```

八进制字面量在严格模式下是无效的，会导致JavaScript弓|擎抛出语法错误。

要创建十六进制字面量，必须让真正的数值前缀Ox (区分大小写)，然后是十六进制数字(0~9以及A~F).十六进制数字中的字母大小写均可。下面是几个例子:
```js
let hexNum1 = 0xA; //十六进制10
let hexNum2 = 0x1f; // 十六进制31
```

使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

注意由于JavaScript保存数值的方式，实际中可能存在正零(+0) 和负零(-0)、正零和负零在所有情况下都被认为是等同的，这里特地说明一下。

**1.浮点值**


要定义浮点值，数值中必须包含小数点,而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子:

```js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐
```
因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0 (如1.0)
```js
let floatNum1 = 1;//小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0; //小数点后面是零，当成整数10处理
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值(整数或浮点数)后跟一个大写或小写的字母e,再加上一个要乘的10的多少次幂。比如:
```js
let floatNum = 3.125e7; //等于31250000
```

在这个例子中，floatNum等 于31250000 ,只不过科学记数法显得更简洁。这种表示法实际上相当于说:”以3.125作为系数， 乘以10的7次幂。”

科学记数法也可以用于表示非常小的数值，例如0.0000000000000003.这个数值用科学记数法可以表示为3e-17。默认情况下,ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法(例如，0.0000003会被转换为3e-7)。术计算中远不如整数精确。

例如，0.1加0.2得到的不是0.3而是0.3000000000000004。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下面的例子:
```js
if(a + b==0.3) {//别这么干!
    console.log("You got 0.3.");
}
```
这里检测两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15,那没问题。但如果是0.1和0.2,如前所述，测试将失败。因此永远不要测试某个特定的浮点值。

注意之所以存在这种舍入错误，是因为使用了IEEE754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。

**2.值得范围**

由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN VALUE中，这个值在多数浏览器中是5e-324;可以表示的最大数值保存在Number.MAX_ VALUE中，这个值在多数浏览器中是1.797693134862315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity (无穷)值。任何无法表示的负数以-Infinity (负无穷大)表示，任何无法表示的正数以Infinity (正无穷大)表示。

如果计算返回正Infinity或负Infinity,则该值将不能再进一步用于任何计算。这是因为Infinity没有可用于计算的数值表示形式。要确定一个值是不是有限大(即介于JavaScript能表示的最小值和最大值之间)可以使用isFinite()函数，如下所示:

```js
let result = Number.MAX VALUE + Number.MAX VALUE;
console.log(isFinite(result)); // false
```

虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果 是否超出范围。

注意使用Number.NEGATIVE INFINITY和Number.POSITIVE INFINITY也可以获取正、负Infinity。 没错，这两个属性包含的值分别就是-Infinity和Infinity。

**3.NaN**

有一个特殊的数值叫NaN，意思是"不是数值"(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误) 。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相 除会返回NaN:

```js
console.log(0/0);// NaN
console.log(-0/+0); // NaN 
```
如果分子是非0值，分母是有符号0或无符号0,则会返Infinity或-Infinity:

```js
console.log(5/0); // Infinity
console.log(5/-0); // -Infinity
```

NaN有几个独特的属性。首先，任何涉及NaN的操作始终返回NaN (如NaN/10).在连续多步计算时这可能是个问题。其次,NaN不等于包括NaN在内的任何值。例如，下面的比较操作会返回false: 

```js
console.log(NaN == NaN); //false
```

为此，ECMAScript提供 了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否"不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下: 
```js
console.log(isNaN(NaN));// true
console.log(isNaN(10)); // false, 10是数值
console.log(isNaN("10")); // false,可以转换为数值10
console.log(isNaN("blue")); // true,不可以转换为数值
console.log(isNaN(true));// false,可以转换为数值1
```

上述的例子测试了5个不同的值。首先测试的是NaN本身，显然会返回true。接着测试了数值10和字符串"10"， 都返回false， 因为它们的数值都是10。字符串"blue"不能转换为数值，因此函数返回true。布尔值true可以转换为数值1，因此返回false。

注意虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString(方法,并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式


**4.数值转换**

有3个函数可以将非数值转换为数值:

Number()、parselnt()和parseFloat()。

Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number()函数基于如下规则执行转换。

* 布尔值，true转换为1， false转换为0
* 数值，直接返回
* null,返回0
* undefined,返回NaN
* 字符串，应用一下规则
  * 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此Number("1")返回1,Number("123")返回123,Number("011")返回11 (忽略前面的零)
  * 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值(同样，忽略前面的零)
  * 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值。
  * 如果是空字符串(不包含字符)则返回0。
  * 如果字符串包含除上述情况之外的其他字符，则返回NaN。
* 对象，调用valueOf()方法，并按照上述规则转换返回的值。如果转换结果是NaN,则调用toString(方法，再按照转换字符串的规则转换。

从不同数据类型到数值的转换有时候会比较复杂，看一看Number)的转换规则就知道了。下面是几个具体的例子:

```js
let num1 = Number("Hello world! "); //NaN
let num2 = Number("");//0
let num3 = Number("000011");// 11
let num4 = Number(true);// 1
```

可以看到，字符串"Hello world"转换之后是NaN,因为它找不到对应的数值。空字符串转换后是0。字符串000011转换后是11，因为前面的零被忽略了。最后，true转换为1。

考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数。 

parselnt()函数更专注于字符串是否包含数值模式。

字符串最前面的空格会被忽略，从第一一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parselnt()立即返回NaN。 

这意味着空字符串也会返回NaN (这一 -点跟Number(不一样，它返回0)。

如果第一一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。

比如"1234blue"会被转换为1234 ,因为"blue"会被完全忽略。类似地，"22.5"会被转换为22，因为小数点不是有效的整数字符。

假设字符串中的第一个字符是数值字符，parselnt()函数也能识别不同的整数格式(十进制、八进制、十六进制)。换句话说，如果字符串以"0x"开头，就会被解释为十六进制整数。如果字符串以"0"开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。

下面几个转换示例有助于 理解上述规则:

```js
let num1 = parseInt("1234blue"); // 1234
let num2 = parselnt("");// NaN
let num3 = parselnt("OxA");//10，解释为十六进制整数
let num4 = parselnt(22.5);// 22
let num5 = parselnt("70");// 70，解释为十进制值
let num6 = parselnt("0xf");// 15，解释为十六进制整数
```

不同的数值格式很容易混淆，因此parselnt()也接收第二个参数，用于指定底数(进制数)。如果知道要解析的值是十六进制，那么可以传入16作为第二个参数，以便正确解析:

```js
let num = parselnt("0xAF", 16); // 175
```

事实上，如果提供了十六进制参数，那么字符串前面的"Ox"可以省掉:

```js
let num1 = parselnt("AF", 16); // 175
let num2 = parselnt("AF");// NaN
```

在这个例子中，第一个转换是正确的，而第二个转换失败了。

区别在于第一次传入了进制数作为参数，告诉parseInt()要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字符，随即自动停止并返回NaN。

通过第二个参数，可以极大扩展转换后获得的结果类型。比如:

```js
let num1 = parselnt("10",2); //2，按二进制解析
let num2 = parselnt("10", 8); //8， 按八进制解析
let num3 = parselnt("10", 10); // 10，按十进制解析
let num4 = parselnt("10", 16); // 16,按十六进制解析
```

因为不传底数参数相当于让parselnt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。

注意多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。

parseFloat()函数的工作方式跟parselnt()函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点现的小数点是有效的，但第二次出现的小数点略。因此，"22.34.5"将转换成22.34。

parseFloat()函数的另一一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式(开头的零始终被忽略)。十六进制数值始终会返回0。因为parseFloat() 只解析十进制值，因此不能指定底数。最后，如果字符串表示整数(没有小数点或者小数点后面只有一一个零)则parseFloat()返回整数。下面是几个示例:

```js
let num1 = parseFloat(" 1234blue"); //1234,按整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5");// 22.5
let num4 = parseFloat( "22.34.5");// 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); //31250000
```

### String类型

String (字符串)数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号(")、单引号(') 或反引号()标示，因此下面的代码都是合法的: 

```js
let firstName = "John"; 
let lastName = 'Jacob';
let lastName = `Jingleheimerschmidt`
```

跟某些语言中使用不同的引|号会改变对字符串的解释方式不同，ECMAScript语法中表示字符串的引|号没有区别。不过要注意的是，以某种弓|号作为字符串开头，必须仍然以该种引号作为字符串结尾。比如，下面的写法会导致语法错误:

```js
let firstName = 'Nicholas"; 
//语法错误:开头和结尾的引号必须是同一种
```

**1.字符字面量**

字符串数据类型包含一些字符字面量， 用于表示非打印字符或有其他用途的字符，如下所示:

| 字面量      | 含义 |
| ----------- | ----------- |
| \n      | 换行       |
| \t   | 制表        |
| \b   | 退格        |
| \r   | 回车        |
| \f   | 换页        |
| \\\   | 反斜杠(\)        |
| \\'   | 单引号( ' ),在字符串以单引号标示时使用，例如'He said, \'hey.\"'        |
| \\"   | 双引号("),在字符串以双引号标示时使用，例如"He said, \"hey. \""        |
| \\`   | 反引号(、),在字符串以反引号标示时使用，例如'He said, \"hey.\"        |
| \xnn   | 以十六进制编码nn表示的字符(其中n是十六进制数字0~F ),例如\x41等于"A"        |
| \unnnn   | 以十六进制编码nnnn表示的Unicode字符(其中n是十六进制数字0~F ),例如\u03a3等于希腊字符"∑"        |

这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释:
```js
let text = "This is the letter sigma: \u03a3.";
```

在这个例子中，即使包含6个字符长的转义序列，变量text仍然是28个字符长。因为转义序列表示一个字符，所以只算一个字符。

字符串的长度可以通过其length属性获取:

```js
console.log(text.length); // 28
```

这个属性返回字符串中1 6位字符的个数。

注意如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数

**2.字符串的特点**

ECMAScript中的字符串是不可变的\(immutable),意思是一旦创建,它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量， 如下所示:

```js
let lang = "Java";
lang = lang + "Script"; 
```

这里，变量lang开始包含字符串"Java"。紧接着,lang被重新定义为包含"Java"和"Script”的 组合，也就是"JavaScript"。整个过程首先会分配一个足够容纳10个字符的空间，然后填充上"Java" 和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器(如Firefox 1.0之前的版本和IE6.0)在拼接字符串时非常慢的地解决了这个问题。