## 数据类型

ECMAScript有6种简单数据类型(也称为原始类型) : 

Undefined、Null、Boolean、Number、 String和Symbol。 Symbol (符号)是ECMAScript 6新增的。

还有一种复杂数据类型叫object (对象)。Object是一种无序名值对的集合。

因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。

只有7种数据类型似乎不足以表示全部数据。

但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。

### typeof操作符
因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。

typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一:
* "undefined"表示值未定义;
* "boolean"表示值为布尔值;
* "string"表示值为字符串;
* "number"表示值为数值;
* "object"表示值为对象(而不是函数)或null;
* "function"表示值为函数;
* "symbol"表示值为符号。

下面是使用typeof操作符的例子:

```js
let message = ' some string' ;
console.log(typeof message);// "string"
console.log(typeof(message)); // "string
console.log(typeof 95);// "number"
```

在这个例子中，我们把一个变量( message)和一个数值字面量传给了typeof操作符。

注意，因为typeof是一个操作符而不是函数，所以不需要参数(但可以使用参数)

注意, typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。


**注意**

严格来讲，函数在ECMASrip中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。

### Undefined类型
Undefined类型只有一个值,就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值:

```js
let message;
console.log(message == undefined); //ture
```

在这个例子中，变量message在声明的时候并未初始化。而在比较它和undefined的字面值时，两者是相等的。这个例子等同于如下示例:
```js
let message=undefined;
console.log(message == undefined); // true
```
这里，变量message显 式地以undefined来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得undefined值。

**注意**

一般来说，永远不用显式地给某个变量设置undefined值。字面值undefined主要用于比较，而且在ECMA-262第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针(null) 和未初始化变量的区别。

注意，包含undefined值的变 量跟未定义变量是有区别的。请看下面的例子:

```js
let message;// 这个变量被声明了，只是值为undefined
//确保没有声明过这个变量
// let age
console.log(message); // "undefined"
console.log(age); // 报错
```

在上面的例子中，第一-个console.log会指出变量message的值，即"undefined"。 而第二个console.log要输出一个未声明的变量age的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用typeof。(对未声明的变 量调用delete也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。)在对未初始化的变量调用typeof时，返回的结果是"undefined"，但对未声明的变量调用它时，返回的结果还是"undefined",这就有点让人看不懂了。比如下面的例子:

```js
let message; //这个变量被声明了，只是值为undefined
//确保没有声明过这个变量
//let age
console.log(typeof message);//"undefined" 
console.log(age);//"undefined"
```
无论是声明还是未声明，typeof返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。

**注意**

即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的同时进行初始化。

这样，当typeof返回"undefined"时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

undefined是一个假值。 因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以-定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。

```js
let message; //这个变量被声明了，只是值为undefined
// age没有声明
if (message) {
    //这个块不会执行
}
if(!message) {
    //这个块会执行
}
if (age) {
    //这里会报错
}
```

### Null类型
Null类型同样只有一个值，即特殊值null。 逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因:

```js
let car = null;
console.log(typeof car);
```
在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值。

这样只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如:

```js
if(car != null) {
    //car是一个对象引用
}
```
undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等,如下面的例子所示:
```js
console.log(null == undefined); //true
```

用等于操作符(==) 比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数

即使null和undefined有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为undefined。但null不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。

null是一个假值。 因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是null这个字面值，而不仅仅是假值。

```js
let message = null;
let age;
if (message) {
    //这个块不会执行
}
if (! message) {
    //这个块会执行
}
if(age) {
    //这个块不会执行
}
if!age) {
    //这个块会执行
}
```

### Boolean 类型

Boolean (布尔值)类型是ECMAScript中使用最频繁的类型之一，有两个字面值: true和false。

这两个布尔值不同于数值，因此true不等于1，false不等于0。下面是给变量赋布尔值的例子: 
```js
let found = true;
let lost =false;
```

注意布尔值字面量true和false是区分大小写的，因此True和False (及其他大小混写形式)是有效的标识符，但不是布尔值。虽然布尔值只有两个但所有其他ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的Boolean()转型函数:

```js
let message = "Hello world!";
let messageAsBoolean = Boolean(message);
```
在这个例子中，字符串message会被转换为布尔值并保存在变量messageAsBoolean中。Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为true或false的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。
* 数据类型 - 转化为true的值 - 转化为false的值
* Boolean - true - false
* String - 非空字符串 - ""(空字符串)
* Number - 非零数组(包括无穷值) - 0、NaN
* Object - 任意对象 - null
* Undefined - N/A(不存在) - undefined

理解以上转换非常重要，因为像if等流控制语句会自动执行其他类型值到布尔值的转换，例如:

```js
let message = "Hello world!";
if (message) {
    console.log("Value is true");
}
```
在这个例子中，console.log 会输出字符串"Value is true"，因为字符串message会被自动转换为等价的布尔值true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。

### Number类型

ECMAScript中最有意思的数据类型或许就是Number了。Number类型使用EEE 754格式表示整数和浮点值(在某些语言中也叫双精度值)。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可:
```js
let intNum = 55; //整数
```
整数也可以用八进制(以8为基数)或十六进制(以16为基数)字面量表示。对于八进制字面量，第一一个数字必须是零(0) ,然后是相应的八进制数字(数值0~7)。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成+进制数，如下所示:

```js
let octalNum1 = 070; // 八进制的56
let octalNum2 = 079;//无效的八进制值，当成79处理
let octalNum3 = 08;//无效的八进制值，当成8处理
```

八进制字面量在严格模式下是无效的，会导致JavaScript弓|擎抛出语法错误。

要创建十六进制字面量，必须让真正的数值前缀Ox (区分大小写)，然后是十六进制数字(0~9以及A~F).十六进制数字中的字母大小写均可。下面是几个例子:
```js
let hexNum1 = 0xA; //十六进制10
let hexNum2 = 0x1f; // 十六进制31
```

使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

注意由于JavaScript保存数值的方式，实际中可能存在正零(+0) 和负零(-0)、正零和负零在所有情况下都被认为是等同的，这里特地说明一下。

**1.浮点值**


要定义浮点值，数值中必须包含小数点,而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子:

```js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐
```
因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0 (如1.0)
```js
let floatNum1 = 1;//小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0; //小数点后面是零，当成整数10处理
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值(整数或浮点数)后跟一个大写或小写的字母e,再加上一个要乘的10的多少次幂。比如:
```js
let floatNum = 3.125e7; //等于31250000
```

在这个例子中，floatNum等 于31250000 ,只不过科学记数法显得更简洁。这种表示法实际上相当于说:”以3.125作为系数， 乘以10的7次幂。”

科学记数法也可以用于表示非常小的数值，例如0.0000000000000003.这个数值用科学记数法可以表示为3e-17。默认情况下,ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法(例如，0.0000003会被转换为3e-7)。术计算中远不如整数精确。

例如，0.1加0.2得到的不是0.3而是0.3000000000000004。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下面的例子:
```js
if(a + b==0.3) {//别这么干!
    console.log("You got 0.3.");
}
```
这里检测两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15,那没问题。但如果是0.1和0.2,如前所述，测试将失败。因此永远不要测试某个特定的浮点值。

注意之所以存在这种舍入错误，是因为使用了IEEE754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。

**2.值得范围**

由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN VALUE中，这个值在多数浏览器中是5e-324;可以表示的最大数值保存在Number.MAX_ VALUE中，这个值在多数浏览器中是1.797693134862315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity (无穷)值。任何无法表示的负数以-Infinity (负无穷大)表示，任何无法表示的正数以Infinity (正无穷大)表示。

如果计算返回正Infinity或负Infinity,则该值将不能再进一步用于任何计算。这是因为Infinity没有可用于计算的数值表示形式。要确定一个值是不是有限大(即介于JavaScript能表示的最小值和最大值之间)可以使用isFinite()函数，如下所示:

```js
let result = Number.MAX VALUE + Number.MAX VALUE;
console.log(isFinite(result)); // false
```

虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果 是否超出范围。

注意使用Number.NEGATIVE INFINITY和Number.POSITIVE INFINITY也可以获取正、负Infinity。 没错，这两个属性包含的值分别就是-Infinity和Infinity。

**3.NaN**

有一个特殊的数值叫NaN，意思是"不是数值"(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误) 。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相 除会返回NaN:

```js
console.log(0/0);// NaN
console.log(-0/+0); // NaN 
```
如果分子是非0值，分母是有符号0或无符号0,则会返Infinity或-Infinity:

```js
console.log(5/0); // Infinity
console.log(5/-0); // -Infinity
```

NaN有几个独特的属性。首先，任何涉及NaN的操作始终返回NaN (如NaN/10).在连续多步计算时这可能是个问题。其次,NaN不等于包括NaN在内的任何值。例如，下面的比较操作会返回false: 

```js
console.log(NaN == NaN); //false
```

为此，ECMAScript提供 了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否"不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下: 
```js
console.log(isNaN(NaN));// true
console.log(isNaN(10)); // false, 10是数值
console.log(isNaN("10")); // false,可以转换为数值10
console.log(isNaN("blue")); // true,不可以转换为数值
console.log(isNaN(true));// false,可以转换为数值1
```

上述的例子测试了5个不同的值。首先测试的是NaN本身，显然会返回true。接着测试了数值10和字符串"10"， 都返回false， 因为它们的数值都是10。字符串"blue"不能转换为数值，因此函数返回true。布尔值true可以转换为数值1，因此返回false。

注意虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString(方法,并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式